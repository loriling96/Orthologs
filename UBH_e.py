# Purpose: For every best blast hit, check if the reciprocal blast has a e value below cutoff.
# BLAST files need to be sorted by eval

Usage = "UBH_e.py BLAST1 BLAST2 query_column subject_column eval_column eval_cutoff UBH-list-outfile"

import sys, json, copy

if len(sys.argv) < 8:
	print(Usage)

infl1, infl2, q_col, s_col, eval_col, eval_cutoff, outfile = sys.argv[1:]

# example
# infl1 = 'Chlamy.x.Yeast.BLASTP.e10.txt'
# infl2 = 'Yeast.x.Chlamy.BLASTP.e10.txt'
# q_col = '1'
# s_col = '2'
# eval_col = '4'
# eval_cutoff = '0.1'
## my BLAST files are .csv, generated by blastp -outfmt '10 qseqid sseqid bitscore evalue qcovs'
#query seq-id, subject seq-id, query coverage per subject 

q_col=int(q_col)-1
s_col=int(s_col)-1
eval_col=int(eval_col)-1
eval_cutoff=float(eval_cutoff)


#parse first BLAST results
FL1 = open(infl1, 'r')
D1 = {} #dictionary for BLAST file ONE

#pick the first hit = best BLAST hit
for Line in FL1:
		#columns = Line.rstrip("\n").split(",")
		columns = Line.rstrip("\n").split("\t")
		queryId = columns[q_col]
		subjectId = columns[s_col]
		eval = float(columns[eval_col])
		if ( not ( queryId in D1.keys() ) and eval < eval_cutoff):
			D1[queryId] = [subjectId, eval]

FL1.close()

# Export D1 as txt
# with open('D1_{}.txt' .format(eval_cutoff), 'w') as f:
# 	json.dump(D1,f)

# for each entry in D1, look up the reciplocal eval in FL2
FL2 = open(infl2, 'r')
D1_r = {} #new dictionary for reciprocal-above_cutoff hits
picked=''
for Line in FL2:
		#columns = Line.rstrip("\n").split(",")
		columns = Line.rstrip("\n").split("\t")
		queryId = columns[q_col]
		subjectId = columns[s_col]
		eval = float(columns[eval_col])
		if subjectId == picked: continue # to avoid getting multiple evals from different HSPs of same hit
		if (subjectId in D1.keys() and D1[subjectId][0] == queryId and eval < eval_cutoff):
			D1_r[subjectId] = copy.deepcopy(D1[subjectId])
			D1_r.setdefault(subjectId,[]).append(eval)
			picked = queryId

FL2.close()

# Export D1_r as txt
# with open('D1_r_{}.txt' .format(eval_cutoff), 'w') as f:
# 	json.dump(D1_r,f)

#parse second BLAST results
FL2 = open(infl2, 'r')
D2 = {} #dictionary for BLAST file TWO

#pick the first hit
for Line in FL2:
		#columns = Line.rstrip("\n").split(",")
		columns = Line.rstrip("\n").split("\t")
		queryId = columns[q_col]
		subjectId = columns[s_col]
		eval = float(columns[eval_col])
		if ( not ( queryId in D2.keys() ) and eval < eval_cutoff):
			D2[queryId] = [subjectId,eval]

FL2.close()

# Export D2 as txt
# with open('D2_{}.txt' .format(eval_cutoff), 'w') as f:
# 	json.dump(D2,f)

#Look up the eval in reciprocal BLAST in FL1
FL1 = open(infl1, 'r')
D2_r = {} #new dictionary for reciprocal-above_cutoff (but not necessarily best) hits 

picked=''
for Line in FL1:
		#columns = Line.rstrip("\n").split(",")
		columns = Line.rstrip("\n").split("\t")
		queryId = columns[q_col]
		subjectId = columns[s_col]
		eval = float(columns[eval_col])
		if subjectId == picked: continue
		if (subjectId in D2.keys() and D2[subjectId][0] == queryId and eval < eval_cutoff):
			D2_r[subjectId] = copy.deepcopy(D2[subjectId])
			D2_r.setdefault(subjectId,[]).append(eval)
			picked = queryId

FL1.close()

# Export D2_r as txt
# with open('D2_r_{}.txt' .format(eval_cutoff), 'w') as f:
# 	json.dump(D2_r,f)



#Pick the shared pairs, delete them from both D1_r and D2_r
SharedPairs = {}
D1_unique = copy.deepcopy(D1_r)
D2_unique = copy.deepcopy(D2_r)

for id1 in D1_r.keys():
	value1 = D1_r[id1][0]
	if (value1 in D2_r.keys() ):
		if ( id1 == D2_r[value1][0] ) :
			SharedPairs[value1] = D2_r[value1]
			del D1_unique[id1]

for id1 in SharedPairs.keys():
	if (id1 in D2_r.keys()):
		del D2_unique[id1]


# Export the dicts as txt
# with open('SharedPairs_{}.txt' .format(eval_cutoff), 'w') as f:
# 	json.dump(SharedPairs,f)
# 
# with open('D1_unique_{}.txt' .format(eval_cutoff), 'w') as f:
# 	json.dump(D1_unique,f)
# 
# with open('D2_unique_{}.txt' .format(eval_cutoff), 'w') as f:
# 	json.dump(D2_unique,f)


outfl = open('{}_{}' .format(eval_cutoff, outfile), 'w')

outfl.write("#Unidirectional Best Blast Hits with reciprocal eval < {}\n" .format(eval_cutoff))
outfl.write("#A_id\tB_id\teval_A_vs_B\teval_B_vs_A\tBH_dir\n")

#very clumsy. better way to do this?
for id1 in SharedPairs.keys():
	line = "{}\t{}\t{}\t{}\t{}\n" .format(id1, SharedPairs[id1][0], SharedPairs[id1][1], SharedPairs[id1][2],'A<->B')
	outfl.write(line)

for id1 in D2_unique.keys():
	line = "{}\t{}\t{}\t{}\t{}\n" .format(id1, D2_unique[id1][0], D2_unique[id1][1], D2_unique[id1][2],'A->B')
	outfl.write(line)

for id1 in D1_unique.keys():
	line = "{}\t{}\t{}\t{}\t{}\n" .format(D1_unique[id1][0], id1, D1_unique[id1][2], D1_unique[id1][1],'A<-B')
	outfl.write(line)

outfl.close()

